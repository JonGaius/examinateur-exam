{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getAudioDurationInSeconds = void 0;\nconst ffprobe = require(\"@ffprobe-installer/ffprobe\");\nconst execa = require(\"execa\");\nconst isStream = require(\"is-stream\");\nconst getFFprobeWrappedExecution = (input, ffprobePath) => {\n  const params = ['-v', 'error', '-select_streams', 'a:0', '-show_format', '-show_streams'];\n  const overridenPath = ffprobePath || ffprobe.path;\n  if (typeof input === 'string') {\n    return execa(overridenPath, [...params, input]);\n  }\n  if (isStream(input)) {\n    return execa(overridenPath, [...params, '-i', 'pipe:0'], {\n      reject: false,\n      input\n    });\n  }\n  throw new Error('Given input was neither a string nor a Stream');\n};\n/**\n * Returns a promise that will be resolved with the duration of given audio in\n * seconds.\n *\n * @param input Stream or path to file to be used as\n * input for `ffprobe`.\n * @param [ffprobePath] Optional. Path to `ffprobe` binary. Do not provide any\n * value for this parameter unless you need to override the path to `ffprobe`.\n * Defaults to the path provided by `@ffprobe-installer/ffprobe`, which works in\n * most environments.\n *\n * @return Promise that will be resolved with given audio duration in\n * seconds.\n */\nconst getAudioDurationInSeconds = (input, ffprobePath) => __awaiter(void 0, void 0, void 0, function* () {\n  const {\n    stdout\n  } = yield getFFprobeWrappedExecution(input, ffprobePath);\n  const matched = stdout.match(/duration=\"?(\\d*\\.\\d*)\"?/);\n  if (matched && matched[1]) return parseFloat(matched[1]);\n  throw new Error('No duration found!');\n});\nexports.getAudioDurationInSeconds = getAudioDurationInSeconds;\nexports.default = getAudioDurationInSeconds;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAEA;AACA;AAGA,MAAMA,0BAA0B,GAAG,CACjCC,KAA8B,EAC9BC,WAAoB,KACO;EAC3B,MAAMC,MAAM,GAAG,CACb,IAAI,EACJ,OAAO,EACP,iBAAiB,EACjB,KAAK,EACL,cAAc,EACd,eAAe,CAChB;EAED,MAAMC,aAAa,GAAGF,WAAW,IAAIG,OAAO,CAACC,IAAI;EAEjD,IAAI,OAAOL,KAAK,KAAK,QAAQ,EAAE;IAC7B,OAAOM,KAAK,CAACH,aAAa,EAAE,CAAC,GAAGD,MAAM,EAAEF,KAAK,CAAC,CAAC;;EAGjD,IAAIO,QAAQ,CAACP,KAAK,CAAC,EAAE;IACnB,OAAOM,KAAK,CAACH,aAAa,EAAE,CAAC,GAAGD,MAAM,EAAE,IAAI,EAAE,QAAQ,CAAC,EAAE;MACvDM,MAAM,EAAE,KAAK;MACbR;KACD,CAAC;;EAGJ,MAAM,IAAIS,KAAK,CAAC,+CAA+C,CAAC;AAClE,CAAC;AAED;;;;;;;;;;;;;;AAcA,MAAMC,yBAAyB,GAAG,CAChCV,KAA8B,EAC9BC,WAAoB,KACDU;EACnB,MAAM;IAAEC;EAAM,CAAE,GAAG,MAAMb,0BAA0B,CAACC,KAAK,EAAEC,WAAW,CAAC;EACvE,MAAMY,OAAO,GAAGD,MAAM,CAACE,KAAK,CAAC,yBAAyB,CAAC;EACvD,IAAID,OAAO,IAAIA,OAAO,CAAC,CAAC,CAAC,EAAE,OAAOE,UAAU,CAACF,OAAO,CAAC,CAAC,CAAC,CAAC;EACxD,MAAM,IAAIJ,KAAK,CAAC,oBAAoB,CAAC;AACvC,CAAC;AAGQO;AADTA,kBAAeN,yBAAyB","names":["getFFprobeWrappedExecution","input","ffprobePath","params","overridenPath","ffprobe","path","execa","isStream","reject","Error","getAudioDurationInSeconds","__awaiter","stdout","matched","match","parseFloat","exports"],"sources":["../../src/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}